package com.genesis.dao;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.Date;

import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

/**
 * 
 * @author Imran.Saleem
 *
 */

@Repository
public class DBUtility {

	private static Logger _logger = LoggerFactory.getLogger(DBUtility.class);

	@Autowired JdbcTemplate jdbcTemplate;
  

	public Connection getConnection() throws SQLException{
		DataSource dataSource = jdbcTemplate.getDataSource();
		return dataSource.getConnection();
	}
	
	
	/**
	 * 
	 * @param userId
	 * @param trnCode
	 * @param oprCode
	 * @param terminalId
	 * @param remarks
	 * @return
	 * @throws SQLException
	 */
	public int generateLog(String userId, String trnCode, String oprCode, String terminalId, String remarks) throws SQLException
	{
		Connection    conn = null;
		PreparedStatement   stmt = null;
		try
		{
			int logId = getNextLogId();
			conn = getConnection();
			String query = "INSERT INTO USER_OP_LOG(LOG_ID, USER_ID, TRN_CODE, OPR_CODE, SERVER_DATE, TERMINAL_ID, REMARKS) " +
					"VALUES(?,     ?,     ?,     ?,     ?,     ?,     ?)";
			stmt = conn.prepareStatement(query);
			stmt.setInt      (1, logId);
			stmt.setString   (2, userId);
			stmt.setString   (3, trnCode);
			stmt.setString   (4, oprCode);
			stmt.setTimestamp(5, new Timestamp(new Date().getTime()));
			stmt.setString   (6, terminalId);
			stmt.setString   (7, remarks);
			stmt.executeUpdate();
			conn.commit();
			return logId;
		}
		catch(Exception exc )
		{
			_logger.warn("Error generating orderLog", exc);
			return -1;
		}
		finally
		{
			try { stmt.close(); } catch (Exception e) {}
			try { conn.close(); } catch (Exception e) {}
		}
	}

	
	/**
	 * 
	 * @return
	 * @throws SQLException
	 */
	public int getNextLogId() throws SQLException
	{
		return (new Double(executeFunction
				("BEGIN ? := GET_LOG_ID(); END;", false))).intValue();
	}
   
	
  public String getClientCodeFun() throws SQLException
  {
	 // String clientCode="";
			  return (new String(executeFunctionString
				("BEGIN ? := GET_NCCPL_CLIENT_CODE(); END;", false))).toString();
	 // return clientCode;
  }
  
	

	/**
	 * 
	 * @param query
	 * @param commit
	 * @return
	 * @throws SQLException
	 */
	public double executeFunction(String query, boolean commit)
			throws SQLException
	{
		double value = 0.0;
		Connection connection = null;
		CallableStatement statement  = null;
		try
		{
			connection = getConnection();
			statement = connection.prepareCall(query);
			statement.registerOutParameter (1, Types.NUMERIC);
			statement.execute();
			if (commit) connection.commit();
			value = statement.getDouble(1);
		}
		catch(Exception exc)
		{

		}
		finally
		{
			try {statement.close(); statement = null;} catch (Exception e) {}
			try {connection.close(); connection = null;} catch (Exception e) {}
		}
		return value;
	}
	
	public String executeFunctionString(String query, boolean commit)
			throws SQLException
	{
		String value = "";
		Connection connection = null;
		CallableStatement statement  = null;
		try
		{
			connection = getConnection();
			statement = connection.prepareCall(query);
			statement.registerOutParameter (1, Types.VARCHAR);
			statement.execute();
			if (commit) connection.commit();
			value = statement.getString(1);
		}
		catch(Exception exc)
		{

		}
		finally
		{
			try {statement.close(); statement = null;} catch (Exception e) {}
			try {connection.close(); connection = null;} catch (Exception e) {}
		}
		return value;
	}

}
